<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Interrupt internals | What I Understood</title>
<meta name="keywords" content="">
<meta name="description" content="I&rsquo;ve worked with interrupts before, but as always, I like to understand what&rsquo;s happening under the hood. while I had an intuitive idea of how interrupts might work, I didn&rsquo;t know the specifics for this particular architecture. Now I&rsquo;ll be diving into how interrupts are handled by the ARM Cortex-M4. This is not a tutorial on how to set up interrupts. Instead, it&rsquo;s an explanation of what happens from the moment the NVIC line goes HIGH until the core begins executing your interrupt handler.">
<meta name="author" content="">
<link rel="canonical" href="https://gharbaoui.github.io/posts/interrupts_internals/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.7f7383d596ad77eeb99f6259b4f0db45eaa4ca0ea48a082cbf85a1b397e649c9.css" integrity="sha256-f3OD1Zatd&#43;65n2JZtPDbReqkyg6kiggsv4Whs5fmSck=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://gharbaoui.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://gharbaoui.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://gharbaoui.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://gharbaoui.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://gharbaoui.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://gharbaoui.github.io/posts/interrupts_internals/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" integrity="sha384-nB0miv6/jRmo5UMMR1wu3Gz6NLsoTkbqJghGIsx//Rlm+ZU03BU6SQNC66uf4l5+" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js" integrity="sha384-7zkQWkzuo3B5mTepMUcHkMB5jZaolc2xDwL6VFqjFALcbeS9Ggm/Yr2r3Dy4lfFg" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>


  

<meta property="og:title" content="Interrupt internals" />
<meta property="og:description" content="I&rsquo;ve worked with interrupts before, but as always, I like to understand what&rsquo;s happening under the hood. while I had an intuitive idea of how interrupts might work, I didn&rsquo;t know the specifics for this particular architecture. Now I&rsquo;ll be diving into how interrupts are handled by the ARM Cortex-M4. This is not a tutorial on how to set up interrupts. Instead, it&rsquo;s an explanation of what happens from the moment the NVIC line goes HIGH until the core begins executing your interrupt handler." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://gharbaoui.github.io/posts/interrupts_internals/" />
<meta property="og:image" content="https://gharbaoui.github.io/nvic/mechanism/cover.png" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-12-10T11:01:42+01:00" />
<meta property="article:modified_time" content="2024-12-10T11:01:42+01:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://gharbaoui.github.io/nvic/mechanism/cover.png" />
<meta name="twitter:title" content="Interrupt internals"/>
<meta name="twitter:description" content="I&rsquo;ve worked with interrupts before, but as always, I like to understand what&rsquo;s happening under the hood. while I had an intuitive idea of how interrupts might work, I didn&rsquo;t know the specifics for this particular architecture. Now I&rsquo;ll be diving into how interrupts are handled by the ARM Cortex-M4. This is not a tutorial on how to set up interrupts. Instead, it&rsquo;s an explanation of what happens from the moment the NVIC line goes HIGH until the core begins executing your interrupt handler."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://gharbaoui.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Interrupt internals",
      "item": "https://gharbaoui.github.io/posts/interrupts_internals/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Interrupt internals",
  "name": "Interrupt internals",
  "description": "I\u0026rsquo;ve worked with interrupts before, but as always, I like to understand what\u0026rsquo;s happening under the hood. while I had an intuitive idea of how interrupts might work, I didn\u0026rsquo;t know the specifics for this particular architecture. Now I\u0026rsquo;ll be diving into how interrupts are handled by the ARM Cortex-M4. This is not a tutorial on how to set up interrupts. Instead, it\u0026rsquo;s an explanation of what happens from the moment the NVIC line goes HIGH until the core begins executing your interrupt handler.",
  "keywords": [
    
  ],
  "articleBody": "I’ve worked with interrupts before, but as always, I like to understand what’s happening under the hood. while I had an intuitive idea of how interrupts might work, I didn’t know the specifics for this particular architecture. Now I’ll be diving into how interrupts are handled by the ARM Cortex-M4. This is not a tutorial on how to set up interrupts. Instead, it’s an explanation of what happens from the moment the NVIC line goes HIGH until the core begins executing your interrupt handler. if you’re for a setup tutorial, that would be here\nWhat Happens inside the CORE when Interrupt Occurs? Just to be clear, I’m talking about the orange part.\nBefore diving into how ARM handles interrupts, let’s think about how you would implement it yourself. First, we know that we need a way to figure out the location of the ISR (Interrupt Service Routine) and then jump to it. Let’s assume you have a mechanism for determining this, like a big lookup table, and you successfully manage to jump to the ISR. Great!\nBut what happens when the ISR is done? Oh no—you have no idea where to return! Wait, there’s a solution: before jumping to the ISR, save the current Program Counter (PC) register. That way, at the end of the ISR, you can use it to jump back. Problem solved, right?\nNot quite. There’s another issue: the state of the registers. While inside the ISR, the registers could change, potentially messing up the program that was interrupted. To prevent this, you’d also need to save the current state of the registers before entering the ISR.\nSo, you might end up doing something like this\nmy_isr_stub: push {r0-r12, lr} bl real_isr_action pop {r0-r12, lr} bx lr Well, according to ARM, you don’t need to worry about the “saving/recovering” of registers because it’s handled by hardware.\nlet’s dive into the journey of ARM For now, don’t worry about the priority stuff I’ll explain it later.\nAssuming that I’m not using floating point routines, here’s roughly what should happen.\nLet’s fire up the debugger and see. BTW here’s the source code that For now, I’m using this as a copy paste from the\nprevious article\nint main(void) { // pin setup rcc_periph_clock_enable(RCC_GPIOB); gpio_mode_setup(GPIOB, GPIO_MODE_INPUT, GPIO_PUPD_NONE, GPIO8); rcc_periph_clock_enable(RCC_GPIOA); gpio_mode_setup(GPIOA, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, GPIO5 | GPIO6); rcc_periph_clock_enable(RCC_SYSCFG); // exti setup exti_enable_request(EXTI8); exti_select_source(EXTI8, GPIOB); exti_set_trigger(EXTI8, EXTI_TRIGGER_RISING); nvic_enable_irq(NVIC_EXTI9_5_IRQ); while(1) { gpio_toggle(GPIOA, GPIO5); for (uint32_t i = 0; i \u003c 1000000; ++i); } } void exti9_5_isr(void) { if (exti_get_flag_status(EXTI8)) { gpio_toggle(GPIOA, GPIO6); exti_reset_request(EXTI8); } } Before we enter the ISR After we enter the ISR As you can see, the hardware has saved that state for us, so there’s no need to worry. Here’s a video that might help you get an overview of what we know so far. Some conventions: the ORANGE items are related to hardware, the blue wheel represents normal execution, and the green wheel indicates when the ISR is being executed.\nSummary\nnvic send irqn to core core start stacking and using irqn to get location of isr in vector table, and it will put it in pc I believe you now have an idea of what happens underneath. Let’s move on to other questions? that may arise for you\nWhat happens if two interrupts occurs at the same time? How does the core know where to return? You might have an idea by now, but there’s more to it than you think. What should happen if an ISR is being executed and another interrupt occurs (i.e., ’nested’)? How does the core know where to return? From my memory and background in x86 (Note: If you’re unfamiliar with x86, don’t worry I’m just using it as an example.), functions typically return to the location they were called from using the stack. The top of the stack holds data indicating where to return, and the ret instruction simply pops it and jumps to that location. Those familiar with buffer overflows will understand what’s going on. However, in this case, because doing so would not restore the other registers, we can’t just jump to the previously stored PC on the stack. Remember this?\nAt first, I thought there might be a special return instruction, similar to x86’s iret, but I don’t see one. And surely, ISRs are written like normal functions, so even if there were a special instruction, how would the compiler know where to generate it? Looking at the reference manual, I don’t see a special instruction for returning, so how does the core know that we shouldn’t just jump to the PC on the stack but also restore the state?\nWell, I wasn’t entirely honest at the beginning. When the core sees the IRQ line go high, I said that stacking and vector fetch happen automatically, but that’s not the whole story. There’s more to it than that.\nso lr set to some value that the core will use it later to decide what should happen on return and here’s that value\nso here’s what’s happening\nThat’s interesting there’s no special instruction, but it’s kind of special bx lr. If lr has that specific value, the core doesn’t execute a normal bx. Instead, it performs unstacking as well.\nLet’s check the state of the registers before exiting the ISR.\nSo here’s what the core does when executing bx lr with that value:\nBy now, you should have a general idea of what’s going on.\nSo let’s see the other question.\nWhat happens if two interrupts occurs at the same time? So now, which one should be forwarded to the core to be handled—23 or 6? This is where the priority comes in.\nFrom those pictures, you can see that by setting values at these locations, we are determining which one is more important that is, which interrupt the NVIC should pass to the core.\nlet’s do a simple demo\nint main(void) { // pin setup rcc_periph_clock_enable(RCC_GPIOB); gpio_mode_setup(GPIOB, GPIO_MODE_INPUT, GPIO_PUPD_NONE, GPIO8 | GPIO0); rcc_periph_clock_enable(RCC_GPIOA); gpio_mode_setup(GPIOA, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, GPIO5 | GPIO6 | GPIO7); rcc_periph_clock_enable(RCC_SYSCFG); // exti setup exti_enable_request(EXTI8); exti_select_source(EXTI8, GPIOB); exti_enable_request(EXTI0); exti_select_source(EXTI0, GPIOB); exti_set_trigger(EXTI8, EXTI_TRIGGER_RISING); exti_set_trigger(EXTI0, EXTI_TRIGGER_RISING); nvic_enable_irq(NVIC_EXTI9_5_IRQ); nvic_enable_irq(NVIC_EXTI0_IRQ); nvic_set_priority(NVIC_EXTI9_5_IRQ, 32); // higher value less important red led nvic_set_priority(NVIC_EXTI0_IRQ, 16); // yellow led while(1) { gpio_toggle(GPIOA, GPIO5); for (uint32_t i = 0; i \u003c 1000000; ++i); } } void exti9_5_isr(void) { if (exti_get_flag_status(EXTI8)) { gpio_toggle(GPIOA, GPIO6); exti_reset_request(EXTI8 | EXTI0); } nvic_clear_pending_irq(NVIC_EXTI0_IRQ); } void exti0_isr(void) { gpio_toggle(GPIOA, GPIO7); exti_reset_request(EXTI0 | EXTI8); nvic_clear_pending_irq(NVIC_EXTI9_5_IRQ); } This is the simplest case; you can add subgroups and so on. But if you’ve reached this point, you’re probably good on your own.\nWhat should happen if an ISR is being executed and another interrupt occurs (i.e., ’nested’)? This is no different from the previous case when the main function was executing and an interrupt occurred. The only difference is the value that will be placed in the lr register, so the core knows what to do later.\nOther questions? What will happen if the core is performing stacking and an interrupt occurs at that time? Hint: late arrival Assume you are done with the ISR, but the same interrupt is still pending. Is it worth performing unstacking only to immediately stack again? Hint: `tail chaining. I was intending to answer these questions here, but I found it a bit difficult to demonstrate, so maybe another time.\n",
  "wordCount" : "1219",
  "inLanguage": "en",
  "image":"https://gharbaoui.github.io/nvic/mechanism/cover.png","datePublished": "2024-12-10T11:01:42+01:00",
  "dateModified": "2024-12-10T11:01:42+01:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://gharbaoui.github.io/posts/interrupts_internals/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "What I Understood",
    "logo": {
      "@type": "ImageObject",
      "url": "https://gharbaoui.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://gharbaoui.github.io/" accesskey="h" title="What I Understood (Alt + H)">What I Understood</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://gharbaoui.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://gharbaoui.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://gharbaoui.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://gharbaoui.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Interrupt internals
    </h1>
    <div class="post-meta"><span title='2024-12-10 11:01:42 +0100 +01'>December 10, 2024</span>

</div>
  </header> 
<figure class="entry-cover"><a href="https://gharbaoui.github.io/nvic/mechanism/cover.png" target="_blank"
            rel="noopener noreferrer"><img loading="eager" src="https://gharbaoui.github.io/nvic/mechanism/cover.png" alt=""></a>
        
</figure>
  <div class="post-content"><p>I&rsquo;ve worked with interrupts before, but as always, I like to understand what&rsquo;s happening under the hood.
while I had an intuitive idea of how interrupts might work, I didn&rsquo;t know the specifics for this particular
architecture. Now I&rsquo;ll be diving into how interrupts are handled by the ARM Cortex-M4. This is not a
tutorial on how to set up interrupts. Instead, it&rsquo;s an explanation of what happens from the moment the NVIC
line goes HIGH until the core begins executing your interrupt handler. if you&rsquo;re for a setup tutorial, that
would be <a href="https://gharbaoui.github.io/posts/interrupts/">here</a></p>
<h3 id="what-happens-inside-the-core-when-interrupt-occurs">What Happens inside the CORE when Interrupt Occurs?<a hidden class="anchor" aria-hidden="true" href="#what-happens-inside-the-core-when-interrupt-occurs">#</a></h3>
<p><img loading="lazy" src="/nvic/mechanism/1.png" alt=""  />

Just to be clear, I’m talking about the orange part.</p>
<p>Before diving into how ARM handles interrupts, let’s think about how you would implement it yourself.
First, we know that we need a way to figure out the location of the ISR (Interrupt Service Routine)
and then jump to it. Let’s assume you have a mechanism for determining this, like a big lookup table,
and you successfully manage to jump to the ISR. Great!</p>
<p>But what happens when the ISR is done? Oh no—you have no idea where to return! Wait, there’s a solution:
before jumping to the ISR, save the current Program Counter (PC) register. That way, at the end of the ISR,
you can use it to jump back. Problem solved, right?</p>
<p>Not quite. There’s another issue: the state of the registers. While inside the ISR, the registers
could change, potentially messing up the program that was interrupted. To prevent this, you’d also
need to save the current state of the registers before entering the ISR.</p>
<p>So, you might end up doing something like this</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span>my_isr_stub:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">push</span> <span style="color:#960050;background-color:#1e0010">{</span><span style="color:#66d9ef">r0-r12</span>, <span style="color:#66d9ef">lr</span><span style="color:#960050;background-color:#1e0010">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">bl</span> <span style="color:#66d9ef">real_isr_action</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pop</span> <span style="color:#960050;background-color:#1e0010">{</span><span style="color:#66d9ef">r0-r12</span>, <span style="color:#66d9ef">lr</span><span style="color:#960050;background-color:#1e0010">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">bx</span> <span style="color:#66d9ef">lr</span>
</span></span></code></pre></div><p>Well, according to ARM, you don’t need to worry about the &ldquo;saving/recovering&rdquo; of registers because it’s handled by hardware.</p>
<p><img loading="lazy" src="/nvic/mechanism/2.png" alt=""  />

<img loading="lazy" src="/nvic/mechanism/3.png" alt=""  />
</p>
<p>let&rsquo;s dive into the journey of ARM
<img loading="lazy" src="/nvic/mechanism/4.png" alt=""  />

<img loading="lazy" src="/nvic/mechanism/5.png" alt=""  />
</p>
<p>For now, don’t worry about the priority stuff I’ll explain it later.</p>
<p><img loading="lazy" src="/nvic/mechanism/6.png" alt=""  />

<img loading="lazy" src="/nvic/mechanism/8.png" alt=""  />
</p>
<p>Assuming that I’m not using floating point routines, here’s roughly what should happen.</p>
<p><img loading="lazy" src="/nvic/mechanism/7.png" alt=""  />
</p>
<p>Let’s fire up the debugger and see. BTW here&rsquo;s the source code that For now, I&rsquo;m using this as a copy paste from the</p>
<p><a href="https://gharbaoui.github.io/posts/interrupts/">previous article</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// pin setup
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">rcc_periph_clock_enable</span>(RCC_GPIOB);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">gpio_mode_setup</span>(GPIOB, GPIO_MODE_INPUT, GPIO_PUPD_NONE, GPIO8);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">rcc_periph_clock_enable</span>(RCC_GPIOA);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">gpio_mode_setup</span>(GPIOA, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, GPIO5 <span style="color:#f92672">|</span> GPIO6);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">rcc_periph_clock_enable</span>(RCC_SYSCFG);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// exti setup
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">exti_enable_request</span>(EXTI8);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">exti_select_source</span>(EXTI8, GPIOB);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">exti_set_trigger</span>(EXTI8, EXTI_TRIGGER_RISING);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">nvic_enable_irq</span>(NVIC_EXTI9_5_IRQ);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">gpio_toggle</span>(GPIOA, GPIO5);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint32_t</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1000000</span>; <span style="color:#f92672">++</span>i);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">exti9_5_isr</span>(<span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">exti_get_flag_status</span>(EXTI8)) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">gpio_toggle</span>(GPIOA, GPIO6);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">exti_reset_request</span>(EXTI8);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Before we enter the ISR
<img loading="lazy" src="/nvic/mechanism/10.png" alt=""  />

After we enter the ISR
<img loading="lazy" src="/nvic/mechanism/11.png" alt=""  />

As you can see, the hardware has saved that state for us, so there’s no need to worry.
Here’s a video that might help you get an overview of what we know so far. Some conventions: the ORANGE
items are related to hardware, the blue wheel represents normal execution, and the green wheel indicates when the ISR is being executed.</p>
<iframe
    width='560'
    height='315'
    src='https://www.youtube.com/embed/K_dJYtUVh74?si=STSpmNlO93uWHEJA'
    title="YouTube video player"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    referrerpolicy="strict-origin-when-cross-origin" allowfullscreen>
</iframe>
<p><strong>Summary</strong></p>
<ul>
<li>nvic send irqn to core</li>
<li>core start stacking and using irqn to get location of isr in vector table, and it will put it in pc</li>
</ul>
<p>I believe you now have an idea of what happens underneath. Let&rsquo;s move on to other questions? that may arise for you</p>
<ul>
<li><strong>What happens if two interrupts occurs at the same time?</strong></li>
<li><strong>How does the core know where to return? You might have an idea by now, but there&rsquo;s more to it than you think.</strong></li>
<li><strong>What should happen if an ISR is being executed and another interrupt occurs (i.e., &rsquo;nested&rsquo;)?</strong></li>
</ul>
<h3 id="how-does-the-core-know-where-to-return">How does the core know where to return?<a hidden class="anchor" aria-hidden="true" href="#how-does-the-core-know-where-to-return">#</a></h3>
<iframe
    width='560'
    height='315'
    src='https://www.youtube.com/embed/gT-3Ft6i-Do?si=vXpZY2TVZxBXaUWE'
    title="YouTube video player"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    referrerpolicy="strict-origin-when-cross-origin" allowfullscreen>
</iframe>
<p>From my memory and background in x86 (Note: If you&rsquo;re unfamiliar with x86, don&rsquo;t worry I’m just using it as an example.),
functions typically return to the location they were called from using the stack.
The top of the stack holds data indicating where to return, and the <code>ret</code> instruction simply pops it and jumps to that location.
Those familiar with buffer overflows will understand what&rsquo;s going on. However, in this case,
because doing so would not restore the other registers, we can&rsquo;t just jump to the previously stored PC on the stack. Remember this?</p>
<iframe
    width='560'
    height='315'
    src='https://www.youtube.com/embed/U8rIo5h8-ag?si=1GD4KY99TIggttyv'
    title="YouTube video player"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    referrerpolicy="strict-origin-when-cross-origin" allowfullscreen>
</iframe>
<p>At first, I thought there might be a special return instruction, similar to x86&rsquo;s <code>iret</code>, but I don&rsquo;t see one.
And surely, ISRs are written like normal functions, so even if there were a special instruction, how would the compiler know where to generate it?
Looking at the reference manual, I don&rsquo;t see a special instruction for returning, so how does
the core know that we shouldn&rsquo;t just jump to the PC on the stack but also restore the state?</p>
<p><img loading="lazy" src="/nvic/mechanism/12.png" alt=""  />
</p>
<p>Well, I wasn&rsquo;t entirely honest at the beginning. When the core sees the IRQ line go high,
I said that stacking and vector fetch happen automatically, but that&rsquo;s not the whole story. There&rsquo;s more to it than that.</p>
<p><img loading="lazy" src="/nvic/mechanism/13.png" alt=""  />
</p>
<p>so lr set to some value that the core will use it later to decide what should happen on return and here&rsquo;s that value</p>
<p><img loading="lazy" src="/nvic/mechanism/14.png" alt=""  />

<img loading="lazy" src="/nvic/mechanism/15.png" alt=""  />
</p>
<p>so here&rsquo;s what&rsquo;s happening</p>
<p><img loading="lazy" src="/nvic/mechanism/16.png" alt=""  />
</p>
<p>That&rsquo;s interesting there&rsquo;s no special instruction, but it’s kind of special <code>bx lr</code>.
If <code>lr</code> has that specific value, the core doesn&rsquo;t execute a normal <code>bx</code>. Instead, it performs unstacking as well.</p>
<p>Let&rsquo;s check the state of the registers before exiting the ISR.</p>
<p><img loading="lazy" src="/nvic/mechanism/just_before_return.png" alt=""  />
</p>
<p>So here&rsquo;s what the core does when executing <code>bx lr</code> with that value:</p>
<iframe
    width='560'
    height='315'
    src='https://www.youtube.com/embed/CjidiI6u0IQ?si=9zt4Gfs0--L5p68h'
    title="YouTube video player"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    referrerpolicy="strict-origin-when-cross-origin" allowfullscreen>
</iframe>
<p>By now, you should have a general idea of what&rsquo;s going on.</p>
<p>So let&rsquo;s see the other question.</p>
<h3 id="what-happens-if-two-interrupts-occurs-at-the-same-time">What happens if two interrupts occurs at the same time?<a hidden class="anchor" aria-hidden="true" href="#what-happens-if-two-interrupts-occurs-at-the-same-time">#</a></h3>
<p><iframe
    width='560'
    height='315'
    src='https://www.youtube.com/embed/KaXJ2nMPaGk?si=Q4S82Ha_BRoV9mFU'
    title="YouTube video player"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    referrerpolicy="strict-origin-when-cross-origin" allowfullscreen>
</iframe>
So now, which one should be forwarded to the core to be handled—23 or 6? This is where the priority comes in.</p>
<p><img loading="lazy" src="/nvic/mechanism/18.png" alt=""  />

<img loading="lazy" src="/nvic/mechanism/17_1.png" alt=""  />
</p>
<p>From those pictures, you can see that by setting values at these locations,
we are determining which one is more important that is, which interrupt the <strong>NVIC</strong> should pass to the core.</p>
<p>let&rsquo;s do a simple demo</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// pin setup
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">rcc_periph_clock_enable</span>(RCC_GPIOB);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">gpio_mode_setup</span>(GPIOB, GPIO_MODE_INPUT, GPIO_PUPD_NONE, GPIO8 <span style="color:#f92672">|</span> GPIO0);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">rcc_periph_clock_enable</span>(RCC_GPIOA);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">gpio_mode_setup</span>(GPIOA, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, GPIO5 <span style="color:#f92672">|</span> GPIO6 <span style="color:#f92672">|</span> GPIO7);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">rcc_periph_clock_enable</span>(RCC_SYSCFG);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// exti setup
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">exti_enable_request</span>(EXTI8);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">exti_select_source</span>(EXTI8, GPIOB);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">exti_enable_request</span>(EXTI0);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">exti_select_source</span>(EXTI0, GPIOB);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">exti_set_trigger</span>(EXTI8, EXTI_TRIGGER_RISING);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">exti_set_trigger</span>(EXTI0, EXTI_TRIGGER_RISING);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">nvic_enable_irq</span>(NVIC_EXTI9_5_IRQ);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">nvic_enable_irq</span>(NVIC_EXTI0_IRQ);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">nvic_set_priority</span>(NVIC_EXTI9_5_IRQ, <span style="color:#ae81ff">32</span>); <span style="color:#75715e">// higher value less important red led
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">nvic_set_priority</span>(NVIC_EXTI0_IRQ, <span style="color:#ae81ff">16</span>); <span style="color:#75715e">// yellow led
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">gpio_toggle</span>(GPIOA, GPIO5);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint32_t</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1000000</span>; <span style="color:#f92672">++</span>i);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">exti9_5_isr</span>(<span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">exti_get_flag_status</span>(EXTI8)) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">gpio_toggle</span>(GPIOA, GPIO6);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">exti_reset_request</span>(EXTI8 <span style="color:#f92672">|</span> EXTI0);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">nvic_clear_pending_irq</span>(NVIC_EXTI0_IRQ);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">exti0_isr</span>(<span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">gpio_toggle</span>(GPIOA, GPIO7);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">exti_reset_request</span>(EXTI0 <span style="color:#f92672">|</span> EXTI8);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">nvic_clear_pending_irq</span>(NVIC_EXTI9_5_IRQ);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img loading="lazy" src="/nvic/mechanism/demo_1.gif" alt=""  />
</p>
<p>This is the simplest case; you can add subgroups and so on. But if you&rsquo;ve reached this point, you&rsquo;re probably good on your own.</p>
<h4 id="what-should-happen-if-an-isr-is-being-executed-and-another-interrupt-occurs-ie-nested">What should happen if an ISR is being executed and another interrupt occurs (i.e., &rsquo;nested&rsquo;)?<a hidden class="anchor" aria-hidden="true" href="#what-should-happen-if-an-isr-is-being-executed-and-another-interrupt-occurs-ie-nested">#</a></h4>
<p>This is no different from the previous case when the main function was executing and an interrupt occurred.
The only difference is the value that will be placed in the lr register, so the core knows what to do later.</p>
<h4 id="other-questions">Other questions?<a hidden class="anchor" aria-hidden="true" href="#other-questions">#</a></h4>
<ul>
<li>What will happen if the core is performing stacking and an interrupt occurs at that time? Hint: <code>late arrival</code></li>
<li>Assume you are done with the ISR, but the same interrupt is still pending. Is it worth performing unstacking only to immediately stack again? Hint: `tail chaining.</li>
</ul>
<p>I was intending to answer these questions here, but I found it a bit difficult to demonstrate, so maybe another time.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>

<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Interrupt internals on x"
            href="https://x.com/intent/tweet/?text=Interrupt%20internals&amp;url=https%3a%2f%2fgharbaoui.github.io%2fposts%2finterrupts_internals%2f&amp;hashtags=">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Interrupt internals on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fgharbaoui.github.io%2fposts%2finterrupts_internals%2f&amp;title=Interrupt%20internals&amp;summary=Interrupt%20internals&amp;source=https%3a%2f%2fgharbaoui.github.io%2fposts%2finterrupts_internals%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Interrupt internals on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fgharbaoui.github.io%2fposts%2finterrupts_internals%2f&title=Interrupt%20internals">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Interrupt internals on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fgharbaoui.github.io%2fposts%2finterrupts_internals%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Interrupt internals on whatsapp"
            href="https://api.whatsapp.com/send?text=Interrupt%20internals%20-%20https%3a%2f%2fgharbaoui.github.io%2fposts%2finterrupts_internals%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Interrupt internals on telegram"
            href="https://telegram.me/share/url?text=Interrupt%20internals&amp;url=https%3a%2f%2fgharbaoui.github.io%2fposts%2finterrupts_internals%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Interrupt internals on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Interrupt%20internals&u=https%3a%2f%2fgharbaoui.github.io%2fposts%2finterrupts_internals%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; Mohamed El Gharbaoui 2025.  This work is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a> <a href="https://gharbaoui.github.io/">What I Understood</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
